// 基础的 8x8 点阵字体系统
pub struct Font {
    glyph_width: u32,
    glyph_height: u32,
    glyphs: &'static [[u8; 8]],
}

impl Font {
    pub fn default() -> Self {
        Self {
            glyph_width: 8,
            glyph_height: 8,
            glyphs: &BASIC_FONT,
        }
    }

    pub fn render_char(&self, renderer: &mut crate::renderer::Renderer, x: i32, y: i32, c: char, color: [u8; 4]) {
        if let Some(glyph) = self.get_glyph(c) {
            for (row, &bits) in glyph.iter().enumerate() {
                for col in 0..8 {
                    if (bits >> (7 - col)) & 1 == 1 {
                        renderer.draw_pixel(
                            x + col as i32,
                            y + row as i32,
                            color
                        );
                    }
                }
            }
        }
    }

    fn get_glyph(&self, c: char) -> Option<&[u8; 8]> {
        if c.is_ascii() {
            Some(&self.glyphs[c as usize])
        } else {
            None
        }
    }
}

// 基础的 ASCII 字体数据
static BASIC_FONT: [[u8; 8]; 128] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // NUL
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // SOH
    // ... 前30个控制字符都是空白
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // Space (32)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // !
    [0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00], // "
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00], // #
    [0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00], // $
    [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00], // %
    [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00], // &
    [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // '
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // (
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // )
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // *
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // +
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // ,
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // -
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // .
    [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00], // /
    // 数字 0-9
    [0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00], // 0
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1
    [0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00], // 2
    [0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00], // 3
    [0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00], // 4
    [0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0xC6, 0x7C, 0x00], // 5
    [0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00], // 6
    [0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00], // 7
    [0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00], // 8
    [0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00], // 9
    // ... 其他字符数据将在下一部分继续添加
];